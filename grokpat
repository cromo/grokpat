#!/usr/bin/env python

import re, sys

pattern_files = ["grok-patterns"]

def main(requested_patterns, want_raw):
    patterns = {}
    for pattern_file in pattern_files:
        file = open(pattern_file)
        patterns = dict(patterns.items() + parse_patterns(file))
        file.close()

    invalid_requested_patterns = [p for p in requested_patterns
        if p not in patterns]
    if invalid_requested_patterns:
        for pattern in invalid_requested_patterns:
            sys.stderr.write("Pattern not found: %s\n" % pattern)
        sys.exit(1)

    flattened_requested_patterns = '|'.join(patterns[p] for p in
        requested_patterns)
    if want_raw:
        sys.stdout.write(flattened_requested_patterns)
        sys.exit(0)
    expanded_pattern = expand_grok_subpatterns(flattened_requested_patterns,
        patterns)
    sys.stdout.write(expanded_pattern)

def parse_args(args):
    options = {
        'raw': False,
        'patterns': []
    }
    for arg in args:
        if arg in ('-h', '--help'):
            print_usage()
            sys.exit(0)
        if arg == '--raw':
            options['raw'] = True
        else:
            options['patterns'] += [arg.upper()]
    return options

def print_usage():
    sys.stderr.write("""Usage: %s [--raw] <pattern_name>...

Read and return grok patterns as Ruby regular expressions.

Flags:
--raw      Print the pattern without recursive substitution.
-h --help  Print usage information.
""" % sys.argv[0])

def parse_patterns(file):
    return [separate_name_from_pattern(line.rstrip()) for line in file
        if not is_blank(line) or is_comment(line)]

def is_blank(line):
    return not line.rstrip()

def is_comment(line):
    return line and line.startswith("#")

def separate_name_from_pattern(line):
    return tuple(line.split(' ', 1))

def expand_grok_subpatterns(pattern, pattern_set):
    grok_subpattern_pattern = '%{.+?}'
    if not re.findall(grok_subpattern_pattern, pattern):
        return pattern
    return expand_grok_subpatterns(re.sub(grok_subpattern_pattern,
        lambda m: pattern_set[m.group()[2:-1]], pattern), pattern_set)

if __name__ == "__main__":
    options = parse_args(sys.argv[1:])
    if not options['patterns']:
        sys.stderr.write("Must be called with a pattern name.\n")
        sys.exit(1)
    main(options['patterns'], options['raw'])
